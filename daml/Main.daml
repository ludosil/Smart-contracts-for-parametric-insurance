module Main where

import Daml.Script
import Types
import DA.Date
import DA.Time

template InsurableEventProposal
    with
        proposer : Party
        approver : Party
        insEvt   : InsurableEvent
    where
        signatory proposer 
        observer approver
    
        controller approver can
            InsurableEventProposal_Approve : ContractId InsurableEventApproved
                with
                    observers : [Party]
                do
                    create InsurableEventApproved with
                        approver = approver
                        observers = observers
                        insEvt = insEvt

            InsurableEventProposal_Reject : ()
                do
                    pure()
      
template InsurableEventApproved
    with 
        approver  : Party
        observers : [Party]
        insEvt    : InsurableEvent
    where
        signatory approver
        observer observers

        nonconsuming choice ProposeInsuranceContract : ContractId InsuranceContractProposal
            with
                proposer : Party
                proposee : Party
                asBuyer  : Bool
                notional : Decimal
            controller proposer
            do
                create InsuranceContractProposal with
                    proposer = proposer
                    proposee = proposee
                    asBuyer = asBuyer
                    insEvt = insEvt
                    admin = approver
                    notional = notional

template InsuranceContractProposal
    with
        proposer : Party
        proposee : Party
        asBuyer  : Bool
        insEvt   : InsurableEvent
        admin    : Party
        notional : Decimal
    where
        signatory proposer
        observer proposee, admin
        ensure proposer /= proposee

        controller proposee can 
            InsuranceContractProposal_Accept : ContractId InsuranceContractAgreement
                with
                    -- party1 : Party
                    -- party2 : Party
                    -- buyer : Party
                    -- seller : Party
                    counterpart : Party

                do
                    create InsuranceContractAgreement with
                        -- party1 = party1
                        -- party2 = party2
                        buyer = if asBuyer then counterpart else proposee
                        seller = if asBuyer then proposee else counterpart
                        insEvt = insEvt
                        admin = admin
                        notional = notional

template InsuranceContractAgreement
    with
        -- party1 : Party
        -- party2 : Party
        buyer : Party
        seller : Party
        insEvt   : InsurableEvent
        admin : Party
        notional : Decimal
    where
        signatory buyer, seller
        observer admin
        ensure 
            (buyer /= seller)

        controller admin can

            InsuranceContractAgreement_Approve : (ContractId InsuranceContractApproved, ContractId Balance, ContractId Balance)
                -- with
                --     b1 : ContractId Balance
                --     b2 : ContractId Balance
                do
                    -- (b1Ref, _) <- fetchByKey @Balance (admin, party1)
                    -- (b2Ref, _) <- fetchByKey @Balance (admin, party2)
                    -- archive b1Ref
                    -- archive b2Ref
                    (bBalRef, bBal) <- fetchByKey @Balance (admin, buyer)
                    (sBalRef, sBal) <- fetchByKey @Balance (admin, seller)

                    let premium = (notional * insEvt.premiumPer100) / 100.0
                    assertMsg 
                        "Buyer does not have funds for premium"
                        (bBal.freeFunds > premium)
                    assertMsg 
                        "Seller does not have funds for notional, net of premium received"
                        (sBal.freeFunds + premium > notional)
                    
                    archive bBalRef
                    archive sBalRef
                    
                    bUpdate <- create Balance with
                        party = buyer
                        admin = admin
                        freeFunds = bBal.freeFunds - premium
                        lockedFunds = bBal.lockedFunds
                    sUpdate <- create Balance with
                        party = seller
                        admin = admin
                        freeFunds = sBal.freeFunds - notional + premium
                        lockedFunds = sBal.lockedFunds + notional
                    icApproved <- create InsuranceContractApproved with
                        buyer = buyer
                        seller = seller
                        insEvt = insEvt
                        admin = admin
                        notional = notional
                    return (icApproved, bUpdate, sUpdate)            

template InsuranceContractApproved
    with
        -- party1 : Party
        -- party2 : Party
        buyer : Party
        seller : Party
        insEvt   : InsurableEvent
        admin : Party
        notional : Decimal
    where
        signatory admin
        observer buyer, seller
        ensure 
            (buyer /= seller)

        controller admin can
            EvaluateContract : ContractId InsuranceContractPayout
                with
                    dataSource : [(Date, Decimal)]
                do
                    now <- getTime
                    assertMsg 
                        "Cannot evaluate before expiry" 
                        (now > insEvt.end)
                    let (payoff, exercised) : (Decimal, Bool) = case insEvt.trigger of
                            AboveAtAnyTime strike -> (0.0, any (\(dt,val) -> val > strike) dataSource)
                            BelowAtAnyTime strike -> (0.0, any (\(dt,val) -> val < strike) dataSource)
                            -- AboveFor strike periodInDays -> (0.0, True)
                            -- BelowFor strike periodInDays -> (0.0, True)
                    create InsuranceContractPayout with
                        -- party1 = party1
                        -- party2 = party2
                        buyer = buyer
                        seller = seller
                        insEvt = insEvt
                        admin = admin
                        notional = notional
                        exercised = True

template InsuranceContractPayout
    with
        -- party1       : Party
        -- party2       : Party
        buyer       : Party
        seller       : Party
        insEvt   : InsurableEvent
        admin        : Party
        notional : Decimal
        exercised    : Bool

    where 
        signatory admin

        controller admin can 
            UpdateBalances : (ContractId Balance, ContractId Balance)
                -- with
                --     b1 : ContractId Balance
                --     b2 : ContractId Balance
                do
                    -- (b1Ref, _) <- fetchByKey @Balance (admin, party1)
                    -- (b2Ref, _) <- fetchByKey @Balance (admin, party2)
                    -- archive b1Ref
                    -- archive b2Ref
                    (bBalRef, bBal) <- fetchByKey @Balance (admin, buyer)
                    (sBalRef, sBal) <- fetchByKey @Balance (admin, seller)

                    let premium = (notional * insEvt.premiumPer100) / 100.0

                    archive bBalRef
                    archive sBalRef
                    bUpdate <- create Balance with
                        party = buyer
                        admin = admin
                        freeFunds = if exercised then bBal.freeFunds + notional else bBal.freeFunds
                        lockedFunds = bBal.lockedFunds
                    sUpdate <- create Balance with
                        party = seller
                        admin = admin
                        freeFunds = if not exercised then sBal.freeFunds + notional else sBal.freeFunds
                        lockedFunds = sBal.lockedFunds - notional --freed whatever happens
                    return (bUpdate, sUpdate)
  
template Balance
    with 
        party : Party
        admin : Party
        freeFunds : Decimal
        lockedFunds : Decimal
    where
        signatory admin
        observer party
        
        key (admin, party) : (Party, Party)
        maintainer key._1

--  
setup : Script ()
setup = script do

    -- start on Jan 1
    setTime $ time (date 2020 Jan 1) 00 00 00
    
    -- allocate admin and 3 buyers/sellers
    admin <- allocateParty "Admin"
    p1 <- allocateParty "P1"
    p2 <- allocateParty "P2"
    p3 <- allocateParty "P3"
    let observers = [p1, p2, p3]

    -- admin creates balances
    balance1 <- submit admin do
        createCmd Balance with
            party = p1
            admin = admin
            freeFunds = 100.0
            lockedFunds = 0.0
    balance2 <- submit admin do
        createCmd Balance with
            party = p2
            admin = admin
            freeFunds = 200.0
            lockedFunds = 0.0
    balance3 <- submit admin do
        createCmd Balance with
            party = p3
            admin = admin
            freeFunds = 300.0
            lockedFunds = 0.0


    -- each buyer/seller proposes an insurance event proposal
    prop1 <- submit p1 do
        createCmd InsurableEventProposal with
            proposer = p1
            approver = admin
            insEvt = InsurableEvent with
                pcType = WindSpeed
                start = time (date 2020 Jan 1) 0 0 0
                end = time (date 2020 Dec 31) 0 0 0
                location = (0.0, 0.0) : GPS
                premiumPer100 = 5.0
                trigger = AboveAtAnyTime 100.0


    prop2 <- submit p2 do
        createCmd InsurableEventProposal with
            proposer = p2
            approver = admin
            insEvt = InsurableEvent with
                pcType = RichterScale
                start = time (date 2020 Jan 1) 0 0 0
                end = time (date 2020 Dec 31) 0 0 0
                location = (0.0, 0.0) : GPS
                premiumPer100 = 5.0
                trigger = AboveAtAnyTime 7.0
    
    prop3 <- submit p3 do
        createCmd InsurableEventProposal with
            proposer = p3
            approver = admin
            insEvt = InsurableEvent with
                pcType = Temperature
                start = time (date 2020 Jan 1) 0 0 0
                end = time (date 2020 Dec 31) 0 0 0
                location = (0.0, 0.0) : GPS
                premiumPer100 = 5.0
                trigger = AboveAtAnyTime 45.0

    -- 2 are accepted, 1 is rejected
    approve1 <- submit admin do
        exerciseCmd prop1 InsurableEventProposal_Approve with 
            observers = observers

    approve2 <- submit admin do
        exerciseCmd prop2 InsurableEventProposal_Approve with
            observers = observers

    submit admin do
        exerciseCmd prop3 InsurableEventProposal_Reject

    -- for the 2 accepted events, an insurance contract is proposed
    propIC1 <- submit p1 do
        exerciseCmd approve1 ProposeInsuranceContract with 
            proposer = p1; proposee = p2; asBuyer = True; notional = 100.0
    propIC2 <- submit p2 do
        exerciseCmd approve1 ProposeInsuranceContract with 
            proposer = p2; proposee = p3; asBuyer = False; notional = 100.0
        
    -- the proposed contract is agreed    
    acceptIC1 <- submit p2 do
        exerciseCmd propIC1 InsuranceContractProposal_Accept with 
            counterpart = p1
    
    -- the agreement is approved and the balances updated
    (approveIC1, balance1_int, balance2_int) <- submit admin do
        exerciseCmd acceptIC1 InsuranceContractAgreement_Approve
            -- b1 = balance1
            -- b2 = balance2

    -- agreed contract is evaluated to a payout
    evaluateIC1Fail <- submitMustFail admin do
        exerciseCmd approveIC1 EvaluateContract with
            dataSource = [(date 2020 Dec 31, 0.0)]

    passTime (days 1000)
    evaluateIC1 <- submit admin do
        exerciseCmd approveIC1 EvaluateContract with
            dataSource = [(date 2020 Dec 31, 0.0)]

    updateBalance <- submit admin do
        exerciseCmd evaluateIC1 UpdateBalances
            -- b1 = balance1_int
            -- b2 = balance2_int

    pure()
